<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>悠哉的博客</title>

<!-- SEO meta tags -->
  <meta name="description" content="悠哉的博客，分享生活、旅行、技术与兴趣的个人博客。">
  <meta name="keywords" content="博客, 生活, 技术, 旅行, 悠哉,youzai,fuchenyouzai,拂尘悠哉">

<!-- PWA Manifest -->
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#4CAF50">

<!-- iOS 安装支持 -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="悠哉的博客">
<link rel="apple-touch-icon" href="/icon-192.png">

<!-- 设置 iOS 状态栏样式 -->
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
/* ===== 颜色变量 & 白天/夜晚模式 ===== */
:root {
  --bg-color: #f4f4f4;
  --text-color: #333;
  --header-bg: #4CAF50;
  --footer-bg: #333;
  --footer-text: #fff;
  --article-bg: #fff;
}
body.dark-mode {
  --bg-color: #1e1e1e;
  --text-color: #f4f4f4;
  --header-bg: #333;
  --footer-bg: #222;
  --footer-text: #f4f4f4;
  --article-bg: #2a2a2a;
}

body {
  background-color: var(--bg-color);
  color: var(--text-color);
  font-family: "Helvetica Neue", Arial, sans-serif;
  margin: 0;
  padding: 0;
}

header {
  background-color: var(--header-bg);
  color: white;
  padding: 20px 10px;
  text-align: center;
}

main {
  max-width: 800px;
  margin: 20px auto;
  padding: 0 10px;
}

article {
  background: var(--article-bg);
  color: var(--text-color);
  margin-bottom: 20px;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

h2 { color: #4CAF50; }
img { max-width: 100%; border-radius: 5px; cursor: pointer; transition: transform 0.3s; }
iframe { width: 100%; border: none; border-radius: 5px; }
audio { width: 100%; margin-top: 10px; }

footer {
  text-align: center;
  padding: 15px;
  background: var(--footer-bg);
  color: var(--footer-text);
  margin-top: 20px;
}

.gallery {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
}
.gallery img {
  width: 48%; /* 横向展示，两张图片并排 */
  border-radius: 5px;
  cursor: pointer;
  transition: transform 0.3s;
}
.gallery img:hover {
  transform: scale(1.05);
}

a.telegram-btn, a.admin-btn {
  display: inline-block;
  padding: 10px 15px;
  color: white;
  border-radius: 5px;
  text-decoration: none;
  font-weight: bold;
}
a.telegram-btn { background-color: #0088cc; }
a.telegram-btn:hover { background-color: #006699; }
a.admin-btn { background-color: #e53935; }
a.admin-btn:hover { background-color: #b71c1c; }

.video-container, .article-video {
  position: relative;
  width: 100%;
  padding-bottom: 56.25%;
  height: 0;
  overflow: hidden;
  border-radius: 5px;
  margin: 10px 0;
}
.video-container iframe, .article-video iframe, .video-container #live-player {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border: none;
}

/* ===== 右上角安装按钮（圆形） ===== */
#install-btn {
  position: fixed;
  top: 160px;
  right: 20px;
  z-index: 999;
  width: 80px;
  height: 80px;
  background-color: #4CAF50;
  color: white;
  border-radius: 50%;
  font-size: 14px;
  font-weight: bold;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  cursor: pointer;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  transition: background-color 0.3s, transform 0.2s;
}
#install-btn:hover {
  background-color: #388E3C;
  transform: scale(1.05);
}
@media screen and (max-width: 768px) {
  #install-btn {
    top: 100px;
    width: 70px;
    height: 70px;
    font-size: 13px;
  }
}

/* ===== 右下角悬浮按钮（声音 & 模式） ===== */
#sound-toggle-btn, #mode-toggle-btn {
  position: fixed;
  bottom: 20px;
  z-index: 1000;
  padding: 12px 18px;
  border-radius: 6px;
  font-weight: bold;
  cursor: pointer;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  transition: background-color 0.3s, transform 0.2s;
}
#sound-toggle-btn {
  right: 20px;
  background-color: #e53935;
  color: white;
}
#sound-toggle-btn:hover { background-color: #b71c1c; transform: scale(1.05); }

#mode-toggle-btn {
  right: 140px;
  background-color: #555;
  color: white;
  font-size: 14px;
}
#mode-toggle-btn:hover { background-color: #333; transform: scale(1.05); }
</style>
</head>
<body>
<header>
<h1>悠哉的博客</h1>
<p>分享我的生活与兴趣</p>
</header>

<main>
<article>
<h2>悠哉的Telegram</h2>
<a href="https://t.me/fuchenyouzaibot" target="_blank" class="telegram-btn">联系 Telegram</a>
</article>	

<!-- 全球时间模块（毫秒级同步+自动适配时区） -->
<article>
<h2>全球时间（毫秒级同步）</h2>
<div class="horizontal-module">
  <div class="module-item">
    <p style="font-weight: 600;">UTC 世界时</p>
    <p id="utc-time">00:00:00.000</p>
  </div>
  <div class="module-item">
    <p style="font-weight: 600;">北京（UTC+8）</p>
    <p id="beijing-time">00:00:00.000</p>
  </div>
  <div class="module-item">
    <p style="font-weight: 600;">伦敦（自动夏令时）</p>
    <p id="london-time">00:00:00.000</p>
  </div>
  <div class="module-item">
    <p style="font-weight: 600;">纽约（自动夏令时）</p>
    <p id="newyork-time">00:00:00.000</p>
  </div>
</div>
<p style="font-size: 12px; color: #666; margin-top: 8px; text-align: center;">
  时间更新频率：1毫秒/次 | 时区自动适配（含夏令时）
</p>
</article>

<!-- 时间模块CSS（无需额外依赖，独立完整） -->
<style>
.horizontal-module {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  align-items: center;
  margin-top: 15px;
  padding: 15px;
  background: #f9f9f9;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  width: 100%;
  box-sizing: border-box;
}
.horizontal-module .module-item {
  flex: 1;
  min-width: 120px;
  text-align: center;
}
#utc-time, #beijing-time, #london-time, #newyork-time {
  font-size: 16px;
  font-weight: 600;
  letter-spacing: 0.5px;
  color: #2c3e50;
}
article {
  background: #fff;
  margin: 0 auto 20px;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
  max-width: 1200px;
  width: 100%;
  box-sizing: border-box;
}
h2 { 
  color: #4CAF50; 
  margin-top: 0; 
  border-bottom: 1px solid #eee;
  padding-bottom: 8px;
}
</style>

<!-- 时间模块JS（自动适配夏令时，无需手动维护时区） -->
<script>
document.addEventListener('DOMContentLoaded', () => {
  // 格式化时间（带毫秒+自动时区）
  const formatTimeWithMs = (date, timezone) => {
    const timeStr = date.toLocaleTimeString('zh-CN', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      fractionalSecondDigits: 3,
      hour12: false,
      timeZone: timezone
    });
    // 替换逗号为小数点（统一毫秒格式）
    return timeStr.replace(',', '.');
  };

  // 实时更新时间
  const updateGlobalTime = () => {
    const now = new Date();
    // 各时区时间同步（自动适配夏令时）
    document.getElementById('utc-time').textContent = formatTimeWithMs(now, 'UTC');
    document.getElementById('beijing-time').textContent = formatTimeWithMs(now, 'Asia/Shanghai');
    document.getElementById('london-time').textContent = formatTimeWithMs(now, 'Europe/London');
    document.getElementById('newyork-time').textContent = formatTimeWithMs(now, 'America/New_York');
  };

  // 初始化+毫秒级更新
  updateGlobalTime();
  setInterval(updateGlobalTime, 1);
});
</script>


<!-- 模块开头：GitHub博客专用人民币实时汇率查询与转换工具 -->
<div style="width: 100%; max-width: 800px; margin: 25px auto; padding: 20px; border-radius: 10px; box-shadow: 0 3px 15px rgba(0,0,0,0.06); background: #ffffff; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
  <!-- 标题区域 -->
  <h3 style="margin: 0 0 20px; font-size: 18px; color: #333; border-bottom: 1px solid #f5f5f5; padding-bottom: 10px;">
    人民币实时汇率查询与转换
  </h3>

  <!-- 汇率显示区域 -->
  <div style="margin-bottom: 25px;">
    <h4 style="margin: 0 0 12px; font-size: 14px; color: #666;">当前汇率（1人民币可兑换）</h4>
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
      <!-- 美元汇率卡片 -->
      <div style="padding: 15px; border-radius: 8px; background: #f8f9fa; text-align: center;">
        <div style="font-size: 12px; color: #999; margin-bottom: 5px;">美元 (USD)</div>
        <div id="cny-to-usd" style="font-size: 20px; font-weight: 500; color: #333;">--</div>
        <div id="usd-to-cny" style="font-size: 12px; color: #666; margin-top: 3px;">1 USD ≈ -- CNY</div>
      </div>
      <!-- 日元汇率卡片 -->
      <div style="padding: 15px; border-radius: 8px; background: #f8f9fa; text-align: center;">
        <div style="font-size: 12px; color: #999; margin-bottom: 5px;">日元 (JPY)</div>
        <div id="cny-to-jpy" style="font-size: 20px; font-weight: 500; color: #333;">--</div>
        <div id="jpy-to-cny" style="font-size: 12px; color: #666; margin-top: 3px;">100 JPY ≈ -- CNY</div>
      </div>
      <!-- 港元汇率卡片 -->
      <div style="padding: 15px; border-radius: 8px; background: #f8f9fa; text-align: center;">
        <div style="font-size: 12px; color: #999; margin-bottom: 5px;">港元 (HKD)</div>
        <div id="cny-to-hkd" style="font-size: 20px; font-weight: 500; color: #333;">--</div>
        <div id="hkd-to-cny" style="font-size: 12px; color: #666; margin-top: 3px;">1 HKD ≈ -- CNY</div>
      </div>
    </div>
    <div id="rate-update-time" style="margin-top: 10px; font-size: 12px; color: #999; text-align: right;">
      汇率更新时间：--
    </div>
  </div>

  <!-- 汇率转换区域 -->
  <div>
    <h4 style="margin: 0 0 12px; font-size: 14px; color: #666;">货币转换</h4>
    <div style="display: flex; flex-wrap: wrap; gap: 15px; align-items: center;">
      <!-- 输入金额 -->
      <div style="flex: 1; min-width: 150px;">
        <label style="display: block; font-size: 12px; color: #666; margin-bottom: 5px;">输入金额</label>
        <input 
          id="convert-amount" 
          type="number" 
          min="0" 
          step="0.01" 
          value="1" 
          style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box;"
        >
      </div>
      <!-- 源货币选择 -->
      <div style="min-width: 120px;">
        <label style="display: block; font-size: 12px; color: #666; margin-bottom: 5px;">源货币</label>
        <select id="source-currency" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background: #fff;">
          <option value="CNY">人民币 (CNY)</option>
          <option value="USD">美元 (USD)</option>
          <option value="JPY">日元 (JPY)</option>
          <option value="HKD">港元 (HKD)</option>
        </select>
      </div>
      <!-- 目标货币选择 -->
      <div style="min-width: 120px;">
        <label style="display: block; font-size: 12px; color: #666; margin-bottom: 5px;">目标货币</label>
        <select id="target-currency" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background: #fff;">
          <option value="USD">美元 (USD)</option>
          <option value="JPY">日元 (JPY)</option>
          <option value="HKD">港元 (HKD)</option>
          <option value="CNY">人民币 (CNY)</option>
        </select>
      </div>
      <!-- 转换按钮 -->
      <div style="min-width: 100px; align-self: flex-end; margin-bottom: 24px;">
        <button id="convert-btn" style="width: 100%; padding: 10px; background: #2c3e50; color: #fff; border: none; border-radius: 4px; cursor: pointer; transition: background 0.3s;">
          立即转换
        </button>
      </div>
    </div>
    <!-- 转换结果 -->
    <div id="convert-result" style="margin-top: 15px; padding: 15px; border-radius: 8px; background: #f8f9fa; text-align: center; font-size: 16px; color: #333; display: none;">
      <span id="result-content">1 CNY ≈ 0.14 USD</span>
    </div>
  </div>
</div>

<script>
  // 存储汇率数据（CNY为基础，1 CNY = ? 其他货币）
  let exchangeRates = {};
  // 公开汇率API（无需密钥，适合前端调用）
  const RATE_API_URL = "https://open.er-api.com/v6/latest/CNY";

  // 1. 获取并更新实时汇率
  async function fetchAndUpdateRates() {
    const usdDom = document.getElementById("cny-to-usd");
    const jpyDom = document.getElementById("cny-to-jpy");
    const hkdDom = document.getElementById("cny-to-hkd");
    const usdReverseDom = document.getElementById("usd-to-cny");
    const jpyReverseDom = document.getElementById("jpy-to-cny");
    const hkdReverseDom = document.getElementById("hkd-to-cny");
    const timeDom = document.getElementById("rate-update-time");

    try {
      const response = await fetch(RATE_API_URL);
      const data = await response.json();
      
      if (data.result === "success") {
        // 存储汇率（保留4位小数）
        exchangeRates = {
          USD: parseFloat(data.rates.USD.toFixed(4)),
          JPY: parseFloat(data.rates.JPY.toFixed(4)),
          HKD: parseFloat(data.rates.HKD.toFixed(4)),
          CNY: 1 // 1 CNY = 1 CNY
        };

        // 更新汇率显示（1 CNY 可兑换的其他货币）
        usdDom.textContent = exchangeRates.USD;
        jpyDom.textContent = exchangeRates.JPY;
        hkdDom.textContent = exchangeRates.HKD;

        // 更新反向汇率（1其他货币 可兑换的CNY，保留4位小数）
        usdReverseDom.textContent = `1 USD ≈ ${(1 / exchangeRates.USD).toFixed(4)} CNY`;
        jpyReverseDom.textContent = `100 JPY ≈ ${(100 / exchangeRates.JPY).toFixed(4)} CNY`;
        hkdReverseDom.textContent = `1 HKD ≈ ${(1 / exchangeRates.HKD).toFixed(4)} CNY`;

        // 更新时间（格式：YYYY-MM-DD HH:MM）
        const updateTime = new Date(data.time_last_update_unix * 1000);
        const formattedTime = `${updateTime.getFullYear()}-${(updateTime.getMonth() + 1).toString().padStart(2, "0")}-${updateTime.getDate().toString().padStart(2, "0")} ${updateTime.getHours().toString().padStart(2, "0")}:${updateTime.getMinutes().toString().padStart(2, "0")}`;
        timeDom.textContent = `汇率更新时间：${formattedTime}`;
      } else {
        throw new Error("获取汇率失败，API返回错误");
      }
    } catch (err) {
      console.error("汇率获取错误：", err);
      usdDom.textContent = "获取失败";
      jpyDom.textContent = "获取失败";
      hkdDom.textContent = "获取失败";
      timeDom.textContent = "汇率更新时间：获取失败";
    }
  }

  // 2. 执行货币转换
  function handleCurrencyConvert() {
    const amountInput = document.getElementById("convert-amount");
    const sourceCurrency = document.getElementById("source-currency").value;
    const targetCurrency = document.getElementById("target-currency").value;
    const resultDom = document.getElementById("convert-result");
    const resultContentDom = document.getElementById("result-content");

    // 输入校验
    const amount = parseFloat(amountInput.value);
    if (isNaN(amount) || amount < 0) {
      alert("请输入有效的非负金额");
      return;
    }
    if (!exchangeRates[sourceCurrency] || !exchangeRates[targetCurrency]) {
      alert("汇率数据未加载完成，请稍后再试");
      return;
    }

    // 计算转换结果（保留4位小数）
    // 逻辑：金额 * (1 CNY兑目标货币汇率) / (1 CNY兑源货币汇率)
    const convertedAmount = (amount * exchangeRates[targetCurrency] / exchangeRates[sourceCurrency]).toFixed(4);
    // 显示结果
    resultContentDom.textContent = `${amount} ${sourceCurrency} ≈ ${convertedAmount} ${targetCurrency}`;
    resultDom.style.display = "block";
  }

  // 3. 初始化与事件绑定
  window.addEventListener("DOMContentLoaded", () => {
    // 初始加载汇率
    fetchAndUpdateRates();
    // 每30分钟刷新一次汇率（避免频繁请求API）
    setInterval(fetchAndUpdateRates, 30 * 60 * 1000);

    // 绑定转换按钮点击事件
    document.getElementById("convert-btn").addEventListener("click", handleCurrencyConvert);
    // 绑定回车键触发转换
    document.getElementById("convert-amount").addEventListener("keydown", (e) => {
      if (e.key === "Enter") handleCurrencyConvert();
    });
  });
</script>
<!-- 模块结尾：GitHub博客专用人民币实时汇率查询与转换工具 -->




<!-- 悠哉Telegram Bot博客对话框（无后端版·持续刷新）-->
<div class="tg-bot-chat" style="width: 100%; max-width: 600px; margin: 30px auto; padding: 20px; border-radius: 10px; box-shadow: 0 3px 15px rgba(0,0,0,0.06); background: #fff; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
  <h3 style="margin: 0 0 20px; font-size: 18px; color: #2d3748; text-align: center;">联系悠哉的Telegram Bot</h3>

  <script>
    const BOT_CONFIG = {
      botToken: "8430958771:AAG4bkt9cR5_ZTXgeM3MeH7oSODpMjM6wJs", 
      adminChatId: 6562518027, // 纯数字类型，确保API识别
      updateOffset: 0, 
      refreshInterval: 2000, // 2秒持续刷新，快速同步回复
    };

    // 全局状态
    let messageList = [];
    let refreshTimer = null;
    let isWaitingReply = false;
  </script>

  <!-- 消息显示区 -->
  <div id="messageContainer" style="height: 400px; border: 1px solid #f0f0f0; border-radius: 8px; padding: 15px; margin-bottom: 15px; overflow-y: auto; background: #fafafa; display: flex; flex-direction: column; gap: 12px;">
    <div class="system-msg" style="text-align: center; color: #999; font-size: 14px;">
      无需登录，消息同步Bot，2秒持续自动刷新
    </div>
  </div>

  <!-- 发送消息区 -->
  <div style="display: flex; gap: 10px;">
    <textarea 
      id="userInput" 
      placeholder="输入消息...（Shift+Enter换行，Enter发送）" 
      style="flex: 1; padding: 12px; border: 1px solid #e0e0e0; border-radius: 8px; resize: none; min-height: 60px; font-size: 14px;"
    ></textarea>
    <button 
      id="sendBtn" 
      style="padding: 0 16px; border: none; border-radius: 8px; background: #0088cc; color: #fff; font-size: 14px; cursor: pointer; white-space: nowrap;"
    >
      发送
    </button>
  </div>
  <p id="statusTip" style="margin: 8px 0 0; font-size: 12px; color: #ff4d4f; text-align: right;"></p>
</div>

<!-- 核心功能JS（移除停止刷新逻辑·持续同步） -->
<script>
  const messageContainer = document.getElementById("messageContainer");
  const userInput = document.getElementById("userInput");
  const sendBtn = document.getElementById("sendBtn");
  const statusTip = document.getElementById("statusTip");

  // ------------------------------
  // 功能1：渲染消息（确保样式正常）
  // ------------------------------
  function renderMessages() {
    messageContainer.innerHTML = `
      <div class="system-msg" style="text-align: center; color: #999; font-size: 14px; margin-bottom: 10px;">
        无需登录，消息同步Bot，2秒持续自动刷新
      </div>
    `;

    messageList.forEach(msg => {
      const msgDiv = document.createElement("div");
      if (msg.role === "user") {
        msgDiv.style = "max-width:75%; margin-left:auto; padding:10px 15px; border-radius:12px 12px 0 12px; background:#0088cc; color:#fff; font-size:14px; margin-bottom:8px;";
        msgDiv.innerHTML = `<small>你 · ${formatTime(msg.time)}</small><br>${escapeHtml(msg.content)}`;
      } else if (msg.role === "bot") {
        msgDiv.style = "max-width:75%; margin-right:auto; padding:10px 15px; border-radius:12px 12px 12px 0; background:#e0e0e0; color:#333; font-size:14px; margin-bottom:8px;";
        msgDiv.innerHTML = `<small>Bot · ${formatTime(msg.time)}</small><br>${escapeHtml(msg.content)}`;
      }
      messageContainer.appendChild(msgDiv);
    });
    messageContainer.scrollTop = messageContainer.scrollHeight;
  }

  // ------------------------------
  // 功能2：发送消息（确保API调用成功）
  // ------------------------------
  async function sendUserMessage() {
    const content = userInput.value.trim();
    if (!content) {
      statusTip.textContent = "请输入消息内容！";
      return;
    }

    sendBtn.disabled = true;
    sendBtn.textContent = "发送中...";
    statusTip.textContent = "";

    try {
      // 本地添加用户消息
      const userMsg = { role: "user", content, time: new Date().getTime() };
      messageList.push(userMsg);
      renderMessages();
      userInput.value = "";

      // 用FormData传参，兼容Telegram API
      const telegramUrl = `https://api.telegram.org/bot${BOT_CONFIG.botToken}/sendMessage`;
      const formData = new FormData();
      formData.append("chat_id", BOT_CONFIG.adminChatId);
      formData.append("text", `【博客用户】\n时间：${formatTime(userMsg.time)}\n内容：${content}`);
      formData.append("parse_mode", "HTML");

      const response = await fetch(telegramUrl, {
        method: "POST",
        body: formData
      });

      const result = await response.json();
      if (!result.ok) throw new Error(result.description || "发送失败");

      // 发送成功：启动持续刷新，不停止
      statusTip.textContent = "发送成功！2秒持续刷新回复...";
      isWaitingReply = true;
      startRefreshTimer();

    } catch (err) {
      statusTip.textContent = `发送失败：${err.message}`;
      messageList.pop();
      renderMessages();
    } finally {
      sendBtn.disabled = false;
      sendBtn.textContent = "发送";
    }
  }

  // ------------------------------
  // 功能3：获取回复（核心修改：移除停止刷新逻辑）
  // ------------------------------
  async function fetchBotReplies() {
    try {
      const telegramUrl = `https://api.telegram.org/bot${BOT_CONFIG.botToken}/getUpdates?offset=${BOT_CONFIG.updateOffset + 1}&limit=10`;
      const response = await fetch(telegramUrl);
      const result = await response.json();

      if (!result.ok || !result.result.length) return;

      // 筛选管理员回复
      const newReplies = [];
      result.result.forEach(update => {
        BOT_CONFIG.updateOffset = Math.max(BOT_CONFIG.updateOffset, update.update_id);
        const msg = update.message;
        
        if (
          msg?.from?.id === BOT_CONFIG.adminChatId && 
          msg?.reply_to_message?.text?.includes("【博客用户】")
        ) {
          newReplies.push({
            role: "bot",
            content: msg.text,
            time: msg.date * 1000
          });
        }
      });

      // 有新回复：仅渲染，不停止刷新（核心修改点）
      if (newReplies.length) {
        messageList.push(...newReplies);
        renderMessages();
        isWaitingReply = false;
        statusTip.textContent = "已同步Bot回复，持续2秒刷新..."; // 提示持续刷新
      }

    } catch (err) {
      console.error("获取回复失败：", err);
      statusTip.textContent = `刷新失败：${err.message}，将继续重试...`;
    }
  }

  // ------------------------------
  // 工具函数（无修改）
  // ------------------------------
  function startRefreshTimer() {
    stopRefreshTimer(); // 避免重复定时器
    fetchBotReplies(); // 立即刷新一次
    refreshTimer = setInterval(fetchBotReplies, BOT_CONFIG.refreshInterval);
  }

  function stopRefreshTimer() {
    if (refreshTimer) clearInterval(refreshTimer);
  }

  function formatTime(timestamp) {
    const d = new Date(timestamp);
    return `${d.getFullYear()}-${(d.getMonth()+1).toString().padStart(2,0)}-${d.getDate().toString().padStart(2,0)} ${d.getHours().toString().padStart(2,0)}:${d.getMinutes().toString().padStart(2,0)}`;
  }

  function escapeHtml(unsafe) {
    return unsafe
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;")
      .replace(/\n/g, "<br>");
  }

  // ------------------------------
  // 事件绑定
  // ------------------------------
  sendBtn.addEventListener("click", sendUserMessage);
  userInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      sendUserMessage();
    }
  });

  // 页面初始化与清理
  window.addEventListener("DOMContentLoaded", renderMessages);
  window.addEventListener("beforeunload", stopRefreshTimer); // 页面关闭才停止
</script>






<!-- 悠哉Telegram Bot博客对话框（无后端版·多用户群聊版）-->
<div class="tg-bot-chat" style="width: 100%; max-width: 600px; margin: 30px auto; padding: 20px; border-radius: 10px; box-shadow: 0 3px 15px rgba(0,0,0,0.06); background: #fff; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
  <h3 style="margin: 0 0 20px; font-size: 18px; color: #2d3748; text-align: center;">悠哉Bot群聊</h3>

  <script>
    const BOT_CONFIG = {
      botToken: "8430958771:AAG4bkt9cR5_ZTXgeM3MeH7oSODpMjM6wJs", 
      adminChatId: 6562518027, // 你的管理员ID（纯数字）
      updateOffset: 0, 
      refreshInterval: 2000, // 2秒刷新，同步所有人消息
    };

    // 全局状态：存储所有用户的消息（群聊共享）
    let messageList = [];
    let refreshTimer = null;
    let isWaitingReply = false;
    // 给当前用户生成临时昵称（群聊中区分身份，不存储隐私）
    let userNickname = localStorage.getItem("tg_chat_nickname");
    if (!userNickname) {
      const defaultNames = ["豆包用户", "热心网友", "群聊成员", "访客"];
      userNickname = defaultNames[Math.floor(Math.random() * defaultNames.length)] + Math.floor(Math.random() * 100);
      localStorage.setItem("tg_chat_nickname", userNickname);
    }
  </script>

  <!-- 消息显示区：展示所有人的消息和管理员回复 -->
  <div id="messageContainer" style="height: 400px; border: 1px solid #f0f0f0; border-radius: 8px; padding: 15px; margin-bottom: 15px; overflow-y: auto; background: #fafafa; display: flex; flex-direction: column; gap: 10px;">
    <div class="system-msg" style="text-align: center; color: #999; font-size: 14px; margin-bottom: 5px;">
      群聊模式：所有人可查看消息，管理员会统一回复
    </div>
  </div>

  <!-- 发送消息区：显示当前用户昵称 -->
  <div style="margin-bottom: 8px; font-size: 13px; color: #666;">
    当前昵称：<span style="color: #0088cc; font-weight: 500;">${userNickname}</span>（刷新页面不变，清除浏览器缓存重置）
  </div>
  <div style="display: flex; gap: 10px;">
    <textarea 
      id="userInput" 
      placeholder="输入消息...（Shift+Enter换行，Enter发送）" 
      style="flex: 1; padding: 12px; border: 1px solid #e0e0e0; border-radius: 8px; resize: none; min-height: 60px; font-size: 14px;"
    ></textarea>
    <button 
      id="sendBtn" 
      style="padding: 0 16px; border: none; border-radius: 8px; background: #0088cc; color: #fff; font-size: 14px; cursor: pointer; white-space: nowrap;"
    >
      发送
    </button>
  </div>
  <p id="statusTip" style="margin: 8px 0 0; font-size: 12px; color: #ff4d4f; text-align: right;"></p>
</div>

<!-- 核心功能JS（群聊逻辑：消息共享+全员同步） -->
<script>
  const messageContainer = document.getElementById("messageContainer");
  const userInput = document.getElementById("userInput");
  const sendBtn = document.getElementById("sendBtn");
  const statusTip = document.getElementById("statusTip");
  // 从脚本标签中获取当前用户昵称（避免作用域问题）
  const userNickname = localStorage.getItem("tg_chat_nickname");

  // ------------------------------
  // 功能1：渲染消息（展示所有人的消息+管理员回复，按时间排序）
  // ------------------------------
  function renderMessages() {
    // 清空消息区，先添加系统提示
    messageContainer.innerHTML = `
      <div class="system-msg" style="text-align: center; color: #999; font-size: 14px; margin-bottom: 5px;">
        群聊模式：所有人可查看消息，管理员会统一回复
      </div>
    `;

    // 按时间戳排序（新消息在下方）
    const sortedMessages = [...messageList].sort((a, b) => a.time - b.time);
    
    sortedMessages.forEach(msg => {
      const msgDiv = document.createElement("div");
      // 普通用户消息：显示昵称+内容，靠右
      if (msg.role === "user") {
        msgDiv.style = "max-width:75%; margin-left:auto; padding:10px 15px; border-radius:12px 12px 0 12px; background:#0088cc; color:#fff; font-size:14px;";
        msgDiv.innerHTML = `<small style="font-size: 12px; opacity: 0.8;">${msg.nickname} · ${formatTime(msg.time)}</small><br>${escapeHtml(msg.content)}`;
      } 
      // 管理员回复：显示“管理员”标识+内容，靠左，底色不同
      else if (msg.role === "admin") {
        msgDiv.style = "max-width:75%; margin-right:auto; padding:10px 15px; border-radius:12px 12px 12px 0; background:#4CAF50; color:#fff; font-size:14px;";
        msgDiv.innerHTML = `<small style="font-size: 12px; opacity: 0.8;">管理员 · ${formatTime(msg.time)}</small><br>${escapeHtml(msg.content)}`;
      }
      messageContainer.appendChild(msgDiv);
    });

    // 自动滚动到底部（查看最新消息）
    messageContainer.scrollTop = messageContainer.scrollHeight;
  }

  // ------------------------------
  // 功能2：发送消息（带用户昵称，同步到群聊）
  // ------------------------------
  async function sendUserMessage() {
    const content = userInput.value.trim();
    if (!content) {
      statusTip.textContent = "请输入消息内容！";
      return;
    }

    // 防止重复发送
    if (sendBtn.textContent === "发送中...") return;
    sendBtn.disabled = true;
    sendBtn.textContent = "发送中...";
    statusTip.textContent = "";

    try {
      // 1. 本地先添加当前用户消息（即时显示，提升体验）
      const userMsg = {
        role: "user",        // 标识为普通用户
        nickname: userNickname, // 携带用户昵称
        content: content,
        time: new Date().getTime()
      };
      messageList.push(userMsg);
      renderMessages();
      userInput.value = ""; // 清空输入框

      // 2. 发送到Telegram（让管理员看到消息+昵称，方便回复）
      const telegramUrl = `https://api.telegram.org/bot${BOT_CONFIG.botToken}/sendMessage`;
      const formData = new FormData();
      formData.append("chat_id", BOT_CONFIG.adminChatId);
      // 消息格式：【群聊用户-昵称】时间：内容（管理员能清晰区分是谁发的）
      formData.append("text", `【群聊用户-${userNickname}】\n时间：${formatTime(userMsg.time)}\n内容：${content}`);
      formData.append("parse_mode", "HTML");

      const response = await fetch(telegramUrl, {
        method: "POST",
        body: formData
      });

      const result = await response.json();
      if (!result.ok) throw new Error(result.description || "消息发送失败");

      statusTip.textContent = "消息发送成功！所有人可见";
      isWaitingReply = true;
      startRefreshTimer(); // 启动刷新，等待管理员回复

    } catch (err) {
      // 发送失败：移除本地临时消息，提示错误
      messageList.pop();
      renderMessages();
      statusTip.textContent = `发送失败：${err.message}`;
    } finally {
      sendBtn.disabled = false;
      sendBtn.textContent = "发送";
    }
  }

  // ------------------------------
  // 功能3：获取管理员回复（同步给所有群聊用户）
  // ------------------------------
  async function fetchBotReplies() {
    try {
      const telegramUrl = `https://api.telegram.org/bot${BOT_CONFIG.botToken}/getUpdates?offset=${BOT_CONFIG.updateOffset + 1}&limit=10`;
      const response = await fetch(telegramUrl);
      const result = await response.json();

      if (!result.ok || !result.result.length) return;

      // 筛选管理员的回复（仅同步管理员发给群聊的内容）
      const newReplies = [];
      result.result.forEach(update => {
        // 更新最新的offset，避免重复获取历史消息
        BOT_CONFIG.updateOffset = Math.max(BOT_CONFIG.updateOffset, update.update_id);
        const msg = update.message;

        // 条件：1. 是管理员发送的消息 2. 消息包含“【群聊回复】”标识（管理员回复时需加此标识）
        if (
          msg?.from?.id === BOT_CONFIG.adminChatId && 
          msg?.text?.includes("【群聊回复】")
        ) {
          // 构造管理员回复消息（角色为admin，所有人可见）
          newReplies.push({
            role: "admin",
            content: msg.text.replace("【群聊回复】", "").trim(), // 去掉标识，显示纯回复内容
            time: msg.date * 1000
          });
        }
      });

      // 有新回复：添加到消息列表，全员同步渲染
      if (newReplies.length) {
        messageList.push(...newReplies);
        renderMessages();
        isWaitingReply = false;
        statusTip.textContent = "管理员已回复，所有人可见";
      }

    } catch (err) {
      console.error("获取回复失败：", err);
      statusTip.textContent = `刷新失败：${err.message}，将继续重试...`;
    }
  }

  // ------------------------------
  // 工具函数（时间格式化、防XSS、定时器控制）
  // ------------------------------
  function startRefreshTimer() {
    stopRefreshTimer(); // 清除旧定时器，避免重复
    fetchBotReplies(); // 立即刷新一次
    refreshTimer = setInterval(fetchBotReplies, BOT_CONFIG.refreshInterval);
  }

  function stopRefreshTimer() {
    if (refreshTimer) {
      clearInterval(refreshTimer);
      refreshTimer = null;
    }
  }

  function formatTime(timestamp) {
    const d = new Date(timestamp);
    return `${d.getHours().toString().padStart(2,0)}:${d.getMinutes().toString().padStart(2,0)}`;
  }

  function escapeHtml(unsafe) {
    // 防XSS攻击，过滤特殊字符
    return unsafe
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;")
      .replace(/\n/g, "<br>");
  }

  // ------------------------------
  // 事件绑定（发送、回车触发、页面初始化）
  // ------------------------------
  // 点击发送按钮
  sendBtn.addEventListener("click", sendUserMessage);
  // 回车发送（Shift+Enter换行）
  userInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      sendUserMessage();
    }
  });
  // 页面加载时渲染消息+启动刷新
  window.addEventListener("DOMContentLoaded", () => {
    renderMessages();
    startRefreshTimer();
  });
  // 页面关闭时清除定时器
  window.addEventListener("beforeunload", stopRefreshTimer);
</script>



<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>天气日历模块</title>
    <!-- 外部资源CDN，无需本地配置 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        // Tailwind自定义配置：天气主题色
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        weather: {
                            main: '#4285F4',
                            light: '#E8F0FE',
                            dark: '#1A5FCC',
                            temp: '#FF6D01'
                        }
                    },
                    fontFamily: {
                        inter: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .calendar-grid {
                grid-template-columns: repeat(7, 1fr);
            }
            .weather-shadow {
                box-shadow: 0 3px 15px rgba(66, 133, 244, 0.1);
            }
        }
    </style>
</head>
<body class="bg-gray-50 font-inter p-4 md:p-6">
    <!-- 天气日历主容器 -->
    <div class="max-w-3xl mx-auto bg-white rounded-xl weather-shadow overflow-hidden">
        <!-- 顶部天气信息栏 -->
        <div class="bg-weather-main text-white p-5 md:p-6 flex flex-col md:flex-row justify-between items-center">
            <div>
                <h2 class="text-xl md:text-2xl font-bold flex items-center" id="location">
                    <<i class="fa fa-map-marker mr-2"></</i>
                    <span>获取位置中...</span>
                </h2>
                <p class="text-weather-light mt-1 text-sm md:text-base" id="current-date"></p>
            </div>
            <div class="flex items-center mt-4 md:mt-0">
                <div class="text-3xl md:text-4xl mr-3" id="weather-icon">
                    <<i class="fa fa-cloud"></</i>
                </div>
                <div>
                    <p class="text-2xl md:text-3xl font-bold" id="current-temp">--℃</p>
                    <p class="text-weather-light text-center md:text-right text-sm" id="weather-desc">未知天气</p>
                </div>
            </div>
        </div>

        <!-- 今日天气详情 -->
        <div class="grid grid-cols-2 md:grid-cols-4 gap-3 p-5">
            <div class="bg-weather-light rounded-lg p-3 text-center">
                <p class="text-gray-500 text-xs">湿度</p>
                <p class="text-weather-dark font-bold text-lg mt-1" id="humidity">--%</p>
            </div>
            <div class="bg-weather-light rounded-lg p-3 text-center">
                <p class="text-gray-500 text-xs">风力</p>
                <p class="text-weather-dark font-bold text-lg mt-1" id="wind">-- 级</p>
            </div>
            <div class="bg-weather-light rounded-lg p-3 text-center">
                <p class="text-gray-500 text-xs">日出</p>
                <p class="text-weather-dark font-bold text-lg mt-1" id="sunrise">--:--</p>
            </div>
            <div class="bg-weather-light rounded-lg p-3 text-center">
                <p class="text-gray-500 text-xs">日落</p>
                <p class="text-weather-dark font-bold text-lg mt-1" id="sunset">--:--</p>
            </div>
        </div>

        <!-- 日历标题 -->
        <div class="px-5 py-2 border-t border-gray-100 bg-gray-50">
            <h3 class="text-base font-semibold text-gray-700" id="calendar-month">2024年5月</h3>
        </div>

        <!-- 日历星期头部 -->
        <div class="grid calendar-grid bg-gray-50 border-t border-gray-100">
            <div class="py-2 text-center text-gray-500 text-sm font-medium">日</div>
            <div class="py-2 text-center text-gray-500 text-sm font-medium">一</div>
            <div class="py-2 text-center text-gray-500 text-sm font-medium">二</div>
            <div class="py-2 text-center text-gray-500 text-sm font-medium">三</div>
            <div class="py-2 text-center text-gray-500 text-sm font-medium">四</div>
            <div class="py-2 text-center text-gray-500 text-sm font-medium">五</div>
            <div class="py-2 text-center text-gray-500 text-sm font-medium">六</div>
        </div>

        <!-- 日历日期网格 -->
        <div class="grid calendar-grid" id="calendar-days">
            <!-- 日期由JS动态生成 -->
        </div>
    </div>

    <script>
        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', () => {
            initBasicDate();          // 初始化日期显示
            initWeatherLocation();    // 初始化位置（IP定位→GPS定位→默认大连）
            generateCalendarGrid();   // 生成日历网格
        });

        // 1. 初始化基础日期（当前日期、日历月份）
        function initBasicDate() {
            const now = new Date();
            // 当前日期格式：2024年5月20日 星期一
            const dateOptions = { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' };
            document.getElementById('current-date').textContent = now.toLocaleDateString('zh-CN', dateOptions);
            
            // 日历标题月份：2024年5月
            const monthOptions = { year: 'numeric', month: 'long' };
            document.getElementById('calendar-month').textContent = now.toLocaleDateString('zh-CN', monthOptions);
        }

        // 2. 初始化位置获取（优先级：IP定位 → GPS定位 → 默认大连）
        function initWeatherLocation() {
            // 先尝试IP定位（无需用户授权）
            getLocationByIP()
                .catch(() => {
                    // IP定位失败，尝试GPS定位（需用户授权）
                    return getLocationByGPS();
                })
                .catch(() => {
                    // GPS定位也失败，使用默认大连
                    document.getElementById('location').innerHTML = '<<i class="fa fa-map-marker mr-2"></</i>大连市';
                    getWeatherByCity('大连市');
                });
        }

        // 3. IP定位（通过高德API，无需用户授权）
        function getLocationByIP() {
            return new Promise((resolve, reject) => {
                // 公开测试API Key，确保无需用户申请
                const apiKey = '450f820e5f7485525f6877894608a3f8';
                fetch(`https://restapi.amap.com/v3/ip?key=${apiKey}`)
                    .then(res => res.json())
                    .then(data => {
                        if (data.status === '1' && data.city) {
                            const city = data.city.replace('市', '') + '市'; // 统一格式（如"大连市"）
                            document.getElementById('location').innerHTML = `<<i class="fa fa-map-marker mr-2"></</i>${city}`;
                            getWeatherByCity(city);
                            resolve();
                        } else {
                            reject('IP定位未获取到城市');
                        }
                    })
                    .catch(() => reject('IP定位接口请求失败'));
            });
        }

        // 4. GPS定位（需要用户授权）
        function getLocationByGPS() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject('浏览器不支持GPS定位');
                    return;
                }

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const lat = position.coords.latitude;
                        const lon = position.coords.longitude;
                        getLocationNameByCoord(lat, lon); // 经纬度转城市名
                        getWeatherByCoord(lat, lon);      // 经纬度查天气
                        resolve();
                    },
                    () => reject('用户拒绝GPS定位授权')
                );
            });
        }

        // 5. 经纬度转城市名
        function getLocationNameByCoord(lat, lon) {
            const apiKey = '450f820e5f7485525f6877894608a3f8';
            fetch(`https://restapi.amap.com/v3/geocode/regeo?key=${apiKey}&location=${lon},${lat}`)
                .then(res => res.json())
                .then(data => {
                    if (data.status === '1') {
                        const city = data.regeocode.addressComponent.city || data.regeocode.addressComponent.province;
                        document.getElementById('location').innerHTML = `<<i class="fa fa-map-marker mr-2"></</i>${city}`;
                    }
                });
        }

        // 6. 按城市名查天气（增强稳定性：超时+重试）
        function getWeatherByCity(city) {
            const apiKey = '450f820e5f7485525f6877894608a3f8';
            // 设置5秒超时
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject('请求超时'), 5000)
            );

            Promise.race([
                fetch(`https://restapi.amap.com/v3/weather/weatherInfo?key=${apiKey}&city=${city}&extensions=all`),
                timeoutPromise
            ])
            .then(res => {
                if (!res.ok) throw new Error('接口响应异常');
                return res.json();
            })
            .then(data => {
                if (data.status === '1') {
                    renderWeatherData(data.lives[0], data.forecasts[0]);
                } else {
                    // 接口返回失败，1秒后重试1次
                    setTimeout(() => getWeatherByCity(city), 1000);
                }
            })
            .catch(() => {
                // 请求失败，1秒后重试1次
                setTimeout(() => getWeatherByCity(city), 1000);
            });
        }

        // 7. 按经纬度查天气（增强稳定性：超时+重试）
        function getWeatherByCoord(lat, lon) {
            const apiKey = '450f820e5f7485525f6877894608a3f8';
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject('请求超时'), 5000)
            );

            Promise.race([
                fetch(`https://restapi.amap.com/v3/weather/weatherInfo?key=${apiKey}&location=${lon},${lat}&extensions=all`),
                timeoutPromise
            ])
            .then(res => {
                if (!res.ok) throw new Error('接口响应异常');
                return res.json();
            })
            .then(data => {
                if (data.status === '1') {
                    renderWeatherData(data.lives[0], data.forecasts[0]);
                } else {
                    setTimeout(() => getWeatherByCoord(lat, lon), 1000);
                }
            })
            .catch(() => {
                setTimeout(() => getWeatherByCoord(lat, lon), 1000);
            });
        }

        // 8. 渲染天气数据到页面
        function renderWeatherData(liveData, forecastData) {
            // 基础天气信息
            document.getElementById('current-temp').textContent = `${liveData.temperature}℃`;
            document.getElementById('weather-desc').textContent = liveData.weather;
            document.getElementById('humidity').textContent = `${liveData.humidity}%`;
            document.getElementById('wind').textContent = `${liveData.windpower} 级`;
            
            // 日出日落（截取时分）
            const sunrise = forecastData.casts[0].sunrise?.slice(0, 5) || '--:--';
            const sunset = forecastData.casts[0].sunset?.slice(0, 5) || '--:--';
            document.getElementById('sunrise').textContent = sunrise;
            document.getElementById('sunset').textContent = sunset;

            // 匹配天气图标
            setWeatherIcon(liveData.weather);

            // 日历添加未来天气
            addWeatherToCalendar(forecastData.casts);
        }

        // 9. 设置天气图标（根据天气描述匹配Font Awesome）
        function setWeatherIcon(weatherDesc) {
            const iconEl = document.getElementById('weather-icon');
            const desc = weatherDesc.toLowerCase();

            if (desc.includes('晴')) {
                iconEl.innerHTML = '<<i class="fa fa-sun-o text-yellow-400"></</i>';
            } else if (desc.includes('雨')) {
                iconEl.innerHTML = '<<i class="fa fa-tint text-weather-main"></</i>';
            } else if (desc.includes('雪')) {
                iconEl.innerHTML = '<<i class="fa fa-snowflake-o text-white"></</i>';
            } else if (desc.includes('云') || desc.includes('阴')) {
                iconEl.innerHTML = '<<i class="fa fa-cloud text-gray-400"></</i>';
            } else if (desc.includes('雷')) {
                iconEl.innerHTML = '<<i class="fa fa-bolt text-yellow-500"></</i>';
            } else {
                iconEl.innerHTML = '<<i class="fa fa-cloud"></</i>';
            }
        }

        // 10. 计算农历日期（纯前端计算，支持2024-2028年）
        function getLunarDate(year, month, day) {
            // 农历核心数据：[年总天数, 闰月月份(0无闰月), 各月天数]
            const lunarData = {
                2024: [355, 6, [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30]],
                2025: [384, 6, [29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29]],
                2026: [354, 0, [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29]],
                2027: [384, 2, [29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29]],
                2028: [355, 5, [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30]]
            };
            // 农历月份名称
            const lunarMonths = ['正月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '冬月', '腊月'];
            // 农历日期名称
            const lunarDays = ['初一', '初二', '初三', '初四', '初五', '初六', '初七', '初八', '初九', '初十',
                              '十一', '十二', '十三', '十四', '十五', '十六', '十七', '十八', '十九', '二十',
                              '廿一', '廿二', '廿三', '廿四', '廿五', '廿六', '廿七', '廿八', '廿九', '三十'];

            // 若不在支持年份范围内，返回空
            if (!lunarData[year]) return '';
            const [totalDays, leapMonth, monthDays] = lunarData[year];
            // 计算当前日期距离当年1月1日的天数
            const start = new Date(year, 0, 1);
            const target = new Date(year, month, day);
                        const dayDiff = Math.floor((target - start) / (24 * 60 * 60 * 1000)) + 1;

            let lunarMonth = 1;
            let lunarDay = 0;
            let daysCount = 0;

            // 遍历月份计算农历月和日
            for (let i = 0; i < (leapMonth ? 13 : 12); i++) {
                const days = monthDays[i];
                // 处理闰月（闰月月份前加"闰"）
                if (leapMonth && i === leapMonth) {
                    lunarMonth = `闰${lunarMonths[leapMonth - 1]}`;
                } else if (leapMonth && i > leapMonth) {
                    lunarMonth = lunarMonths[i - 1];
                } else {
                    lunarMonth = lunarMonths[i];
                }

                // 判断当前天数是否在当前农历月内
                if (daysCount + days >= dayDiff) {
                    lunarDay = daysDiff - daysCount;
                    break;
                }
                daysCount += days;
            }

            return `${lunarMonth}${lunarDays[lunarDay - 1]}`;
        }

        // 11. 生成日历网格（含农历+天气）
        function generateCalendarGrid() {
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth();
            const today = now.getDate();
            const daysEl = document.getElementById('calendar-days');
            daysEl.innerHTML = '';

            // 当月第一天是星期几（0=周日，6=周六）
            const firstDayOfMonth = new Date(year, month, 1).getDay();
            // 当月总天数
            const totalDaysOfMonth = new Date(year, month + 1, 0).getDate();
            // 上月总天数
            const totalDaysOfLastMonth = new Date(year, month, 0).getDate();

            // 1. 填充上月残留日期（含农历）
            for (let i = 0; i < firstDayOfMonth; i++) {
                const dayNum = totalDaysOfLastMonth - firstDayOfMonth + 1 + i;
                const lastMonthDate = new Date(year, month - 1, dayNum);
                const lunar = getLunarDate(lastMonthDate.getFullYear(), lastMonthDate.getMonth(), lastMonthDate.getDate());
                
                const dayEl = document.createElement('div');
                dayEl.className = 'py-2 text-center text-gray-300 border-t border-gray-100';
                dayEl.innerHTML = `
                    <span class="block text-sm">${dayNum}</span>
                    <span class="block text-xs mt-1">${lunar}</span>
                `;
                daysEl.appendChild(dayEl);
            }

            // 2. 填充当月日期（含农历，今日特殊标记）
            for (let i = 1; i <= totalDaysOfMonth; i++) {
                const isToday = i === today;
                const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(i).padStart(2, '0')}`;
                const lunar = getLunarDate(year, month, i);

                const dayEl = document.createElement('div');
                // 基础样式（今日特殊高亮）
                dayEl.className = `py-2 text-center border-t border-gray-100 transition-colors ${
                    isToday ? 'bg-weather-main text-white font-medium' : 'hover:bg-weather-light'
                }`;

                // 日期内容（公历+农历，今日加"今天"标签）
                dayEl.innerHTML = `
                    <span class="block text-sm">${i}</span>
                    <span class="block text-xs mt-1">${lunar}</span>
                    ${isToday ? '<span class="text-xs mt-1 bg-white/20 rounded px-1">今天</span>' : ''}
                `;

                // 标记日期，用于后续绑定天气
                dayEl.dataset.date = dateStr;
                daysEl.appendChild(dayEl);
            }

            // 3. 填充下月日期（含农历）
            const lastDayOfMonth = new Date(year, month, totalDaysOfMonth).getDay();
            const nextMonthFillDays = 6 - lastDayOfMonth;
            for (let i = 1; i <= nextMonthFillDays; i++) {
                const nextMonthDate = new Date(year, month + 1, i);
                const lunar = getLunarDate(nextMonthDate.getFullYear(), nextMonthDate.getMonth(), nextMonthDate.getDate());
                
                const dayEl = document.createElement('div');
                dayEl.className = 'py-2 text-center text-gray-300 border-t border-gray-100';
                dayEl.innerHTML = `
                    <span class="block text-sm">${i}</span>
                    <span class="block text-xs mt-1">${lunar}</span>
                `;
                daysEl.appendChild(dayEl);
            }
        }

        // 12. 给日历日期添加天气信息（高低温+图标）
        function addWeatherToCalendar(casts) {
            casts.forEach(cast => {
                const dateStr = cast.date; // 格式：2024-05-20
                const dayEl = document.querySelector(`[data-date="${dateStr}"]`);
                
                if (dayEl) {
                    // 匹配天气图标
                    let icon = '';
                    if (cast.dayweather.includes('晴')) {
                        icon = '<<<i class="fa fa-sun-o text-yellow-400 text-xs"></</</i>';
                    } else if (cast.dayweather.includes('雨')) {
                        icon = '<<<i class="fa fa-tint text-weather-main text-xs"></</</i>';
                    } else {
                        icon = '<<<i class="fa fa-cloud text-gray-400 text-xs"></</</i>';
                    }

                    // 添加天气信息（避免覆盖今日高亮样式）
                    const weatherHtml = `
                        <div class="mt-1 text-xs ${dayEl.classList.contains('bg-weather-main') ? 'text-white' : 'text-gray-600'}">
                            ${icon}
                            <span>${cast.daytemp}°/${cast.nighttemp}°</span>
                        </div>
                    `;
                    dayEl.insertAdjacentHTML('beforeend', weatherHtml);
                }
            });
        }

        // 13. 天气加载失败处理（强制切换大连天气）
        function showWeatherError() {
            document.getElementById('location').innerHTML = '<<<i class="fa fa-map-marker mr-2"></</</i>大连市';
            getWeatherByCity('大连市');
            
            // 临时显示加载提示
            document.getElementById('current-temp').textContent = '加载中...';
            document.getElementById('weather-desc').textContent = '正在获取天气';
        }
    </script>
</body>
</html>

















<!-- 模块开头：GitHub博客专用音乐播放器 -->
<div style="width: 100%; max-width: 800px; margin: 25px auto; padding: 20px; border-radius: 10px; box-shadow: 0 3px 15px rgba(0,0,0,0.06); background: #ffffff; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
  <!-- 音乐配置区：直接添加/修改音乐信息即可 -->
  <script>
    // 👇 核心配置：音乐列表（支持多首，可添加/删除，每首需填写title、artist、url）
    const musicList = [
      {
        title: "光年之外",       // 音乐标题
        artist: "邓紫棋",     // 歌手
        url: "https://lu-sycdn.kuwo.cn/be8a87d5df5f5bfb5ecf63eec5ff2522/68d2579f/resource/a2/25/64/2640583885.aac", // 音乐文件URL（需是公开可访问的MP3链接）
        cover: "https://example.com/covers/gu Yongzhe.jpg" // 可选：专辑封面图URL
      },
      {
        title: "起风了",
        artist: "买辣椒也用券",
        url: "https://example.com/music/qi Fengle.mp3",
        cover: "https://example.com/covers/qi Fengle.jpg"
      },
      {
        title: "小幸运",
        artist: "田馥甄",
        url: "https://example.com/music/xiao Xingyun.mp3",
        cover: "https://example.com/covers/xiao Xingyun.jpg"
      }
    ];

    // 当前播放索引（默认从第1首开始）
    let currentMusicIndex = 0;
  </script>

  <!-- 播放器主体 -->
  <div style="display: flex; align-items: center; gap: 20px; flex-wrap: wrap;">
    <!-- 专辑封面 -->
    <div style="position: relative; width: 120px; height: 120px; border-radius: 8px; overflow: hidden; flex-shrink: 0;">
      <img id="musicCover" src="" alt="专辑封面" style="width: 100%; height: 100%; object-fit: cover;">
      <!-- 封面旋转动画（播放时生效） -->
      <style>
        @keyframes rotate {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        .rotating { animation: rotate 10s linear infinite; }
      </style>
    </div>

    <!-- 音乐信息与控制区 -->
    <div style="flex: 1; min-width: 250px;">
      <!-- 音乐标题与歌手 -->
      <h3 id="musicTitle" style="margin: 0 0 8px; font-size: 18px; color: #333;">--</h3>
      <p id="musicArtist" style="margin: 0 0 15px; font-size: 14px; color: #666;">--</p>

      <!-- 进度条 -->
      <div style="width: 100%; margin-bottom: 12px;">
        <input 
          id="musicProgress" 
          type="range" 
          min="0" 
          max="100" 
          value="0" 
          style="width: 100%; height: 4px; appearance: none; background: #f2f2f2; border-radius: 2px; outline: none;"
        >
        <!-- 进度条样式优化（兼容主流浏览器） -->
        <style>
          #musicProgress::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #2c3e50;
            cursor: pointer;
          }
          #musicProgress::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #2c3e50;
            cursor: pointer;
            border: none;
          }
        </style>
      </div>

      <!-- 时间与控制按钮 -->
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span id="musicTime" style="font-size: 12px; color: #999;">00:00 / 00:00</span>
        <div style="display: flex; gap: 15px; align-items: center;">
          <button id="prevBtn" style="background: none; border: none; font-size: 20px; color: #2c3e50; cursor: pointer;">⏮</button>
          <button id="playPauseBtn" style="background: #2c3e50; color: #fff; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;">▶</button>
          <button id="nextBtn" style="background: none; border: none; font-size: 20px; color: #2c3e50; cursor: pointer;">⏭</button>
        </div>
      </div>
    </div>
  </div>

  <!-- 音乐列表（可选显示） -->
  <div style="margin-top: 20px; border-top: 1px solid #f5f5f5; padding-top: 15px;">
    <h4 style="margin: 0 0 10px; font-size: 14px; color: #666;">播放列表</h4>
    <ul id="musicPlaylist" style="margin: 0; padding: 0; list-style: none;">
      <!-- 列表项由JS动态生成 -->
    </ul>
  </div>
</div>

<script>
  // 初始化音频元素
  const audio = new Audio();
  // 获取DOM元素
  const playPauseBtn = document.getElementById("playPauseBtn");
  const prevBtn = document.getElementById("prevBtn");
  const nextBtn = document.getElementById("nextBtn");
  const musicProgress = document.getElementById("musicProgress");
  const musicTime = document.getElementById("musicTime");
  const musicTitle = document.getElementById("musicTitle");
  const musicArtist = document.getElementById("musicArtist");
  const musicCover = document.getElementById("musicCover");
  const musicPlaylist = document.getElementById("musicPlaylist");
  const coverDom = document.querySelector("#musicCover").parentElement;

  // 加载指定索引的音乐
  function loadMusic(index) {
    const music = musicList[index];
    audio.src = music.url;
    musicTitle.textContent = music.title;
    musicArtist.textContent = music.artist;
    // 加载封面（若无则用默认图）
    musicCover.src = music.cover || "https://via.placeholder.com/120x120?text=Music";
    // 更新当前播放索引
    currentMusicIndex = index;
    // 更新播放列表选中状态
    updatePlaylistActive();
    // 加载完成后自动播放
    audio.load();
    audio.play().then(() => {
      playPauseBtn.textContent = "⏸";
      coverDom.classList.add("rotating");
    }).catch(err => {
      console.error("播放失败：", err);
      playPauseBtn.textContent = "▶";
      coverDom.classList.remove("rotating");
    });
  }

  // 更新播放列表选中状态
  function updatePlaylistActive() {
    const listItems = musicPlaylist.querySelectorAll("li");
    listItems.forEach((item, index) => {
      if (index === currentMusicIndex) {
        item.style.color = "#2c3e50";
        item.style.fontWeight = "500";
      } else {
        item.style.color = "#666";
        item.style.fontWeight = "normal";
      }
    });
  }

  // 格式化时间（秒转分:秒）
  function formatTime(seconds) {
    const min = Math.floor(seconds / 60);
    const sec = Math.floor(seconds % 60);
    return `${min.toString().padStart(2, "0")}:${sec.toString().padStart(2, "0")}`;
  }

  // 初始化播放列表
  function initPlaylist() {
    musicList.forEach((music, index) => {
      const li = document.createElement("li");
      li.textContent = `${index + 1}. ${music.title} - ${music.artist}`;
      li.style.padding = "6px 0";
      li.style.cursor = "pointer";
      li.addEventListener("click", () => loadMusic(index));
      musicPlaylist.appendChild(li);
    });
  }

  // 事件监听：播放/暂停
  playPauseBtn.addEventListener("click", () => {
    if (audio.paused) {
      audio.play().then(() => {
        playPauseBtn.textContent = "⏸";
        coverDom.classList.add("rotating");
      }).catch(err => console.error("播放失败：", err));
    } else {
      audio.pause();
      playPauseBtn.textContent = "▶";
      coverDom.classList.remove("rotating");
    }
  });

  // 事件监听：上一首
  prevBtn.addEventListener("click", () => {
    currentMusicIndex = (currentMusicIndex - 1 + musicList.length) % musicList.length;
    loadMusic(currentMusicIndex);
  });

  // 事件监听：下一首
  nextBtn.addEventListener("click", () => {
    currentMusicIndex = (currentMusicIndex + 1) % musicList.length;
    loadMusic(currentMusicIndex);
  });

  // 事件监听：进度条拖动
  musicProgress.addEventListener("input", () => {
    const progress = (musicProgress.value / 100) * audio.duration;
    audio.currentTime = progress;
  });

  // 事件监听：音频进度更新
  audio.addEventListener("timeupdate", () => {
    const progressPercent = (audio.currentTime / audio.duration) * 100;
    musicProgress.value = progressPercent;
    musicTime.textContent = `${formatTime(audio.currentTime)} / ${formatTime(audio.duration)}`;
  });

  // 事件监听：音频播放结束（自动下一首）
  audio.addEventListener("ended", () => {
    currentMusicIndex = (currentMusicIndex + 1) % musicList.length;
    loadMusic(currentMusicIndex);
  });

  // 初始化：加载第一首音乐+生成播放列表
  window.addEventListener("DOMContentLoaded", () => {
    initPlaylist();
    loadMusic(0);
  });
</script>
<!-- 模块结尾：GitHub博客专用音乐播放器 -->






	
<!-- 文章内容 -->
<article>
<h2>YouTube直播</h2>
<p>凤凰卫视实时新闻直播</p>
<div class="video-container">
  <div id="live-player">加载中...</div>
</div>
</article>

<article>
<h2>直播频道</h2>
<!-- 直播频道容器 -->
<div id="live-channel-feed" style="display:grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; margin-top: 20px;"></div>
</article>

<article>
<h2>音乐分享1</h2>
<p>一人一首经典曲✌︎˶╹ꇴ╹˶✌︎ </p>
<div class="video-container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/WbW00ghKFt0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
</article>

<article>
<h2>悠哉博文</h2>
<p>这是我的第一篇博客文章，欢迎大家来到我的博客！我会分享生活、技术、旅行和各种有趣的内容。</p>
<!-- 横向展示两张图片 -->
<div class="gallery">
  <img src="https://raw.githubusercontent.com/fuchenyouzai/youzai/main/t2.jpg" alt="图片1">
  <img src="https://raw.githubusercontent.com/fuchenyouzai/youzai/main/t4.jpg" alt="图片2">
</div>
</article>

<article>
  <h2>旅行见闻</h2>
  <p>照片和视频分享</p>
  <div class="article-video">
    <iframe src="https://www.youtube.com/embed/dQw4w9WgXcQ" title="黄石公园短视频" allowfullscreen></iframe>
  </div>
</article>

<article>
  <h2>音乐分享2</h2>
  <p>这是我最近发现 的一首音乐，大家可以试听。</p>
  <audio controls preload="auto" controlsList="nodownload">
    <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg">
    您的浏览器不支持音频播放。
  </audio>
</article>

<article>
<h2>悠哉相册</h2>
<div class="gallery">
<img src="https://raw.githubusercontent.com/fuchenyouzai/youzai/main/t2.jpg" alt="图片1">
<img src="https://raw.githubusercontent.com/fuchenyouzai/youzai/main/t4.jpg" alt="图片3">
</div>
</article>

<article>
<h2>悠哉YouTube</h2>
<a href="https://www.youtube.com/@拂尘悠哉" target="_blank" class="telegram-btn">访问 YouTube</a>
<div id="youtube-feed" style="display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); gap:15px; margin-top:10px;"></div>
</article>

<article>
<h2>悠哉留言板1（Gitalk）</h2>
<div id="gitalk-container"></div>
<a href="https://github.com/fuchenyouzai/youzai/issues" target="_blank" class="admin-btn" style="margin-top:10px;">查看 GitHub 后台评论</a>
</article>

<article>
<h2>悠哉留言板2（Disqus 中文）</h2>
<div id="disqus_thread"></div>
<script>
(function() { 
    var d = document, s = d.createElement('script');
    s.src = 'https://youzaibolg.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
</article>

</main>

<footer>
&copy; 2026 悠哉的博客
</footer>
<!-- 安装按钮 -->
<div id="install-btn">
  安装悠哉博客到设备
</div>

<!-- 右下角按钮 -->
<button id="sound-toggle-btn">🔊 打开声音</button>
<button id="mode-toggle-btn">🌙 夜晚模式</button>

<!-- 新增：左下角全局声音控制按钮（含音量滑块） -->
<div id="global-sound-control" style="position: fixed; bottom: 20px; left: 20px; z-index: 1000; display: flex; align-items: center; gap: 10px; background: rgba(0,0,0,0.5); padding: 8px 12px; border-radius: 8px;">
  <!-- 全局声音开关按钮 -->
  <button id="global-sound-btn" style="padding: 8px 12px; border: none; border-radius: 6px; background-color: #4CAF50; color: white; font-weight: bold; cursor: pointer; transition: background 0.3s;">🔊 全局有声</button>
  <!-- 全局音量滑块 -->
  <div style="display: flex; align-items: center; gap: 5px;">
    <span style="color: white; font-size: 14px;">音量</span>
    <input type="range" id="global-volume-slider" min="0" max="100" value="100" style="width: 100px; accent-color: #4CAF50; cursor: pointer;">
  </div>
</div>

<!-- 原有：右侧音量滑块区域 -->
<div style="position: fixed; bottom: 100px; right: 20px; z-index: 1000; display: flex; align-items: center;">
  <span style="color: white; margin-right: 10px; background-color: rgba(0, 0, 0, 0.5); padding: 3px 6px; border-radius: 4px;">音量</span>
  <input type="range" id="volume-slider" min="0" max="100" value="100" style="width: 100px;">
</div>

<!-- 外部资源引入（保留原结构） -->
<!-- Gitalk -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>

<!-- YouTube IFrame API -->
<script src="https://www.youtube.com/iframe_api"></script>
<script>
// 直播频道数组，每个元素是一个直播的 ID 和标题
const liveChannels = [
  {id: "fN9uYWCjQaw", title: "凤凰卫视直播"},
  {id: "ZB9QSD_SWmM", title: "科技新闻直播"},
  {id: "WbW00ghKFt0", title: "娱乐直播"}
];

// 获取直播频道展示容器
const liveChannelFeed = document.getElementById("live-channel-feed");

// 动态生成每个频道的直播播放器
liveChannels.forEach(channel => {
  const channelWrapper = document.createElement("div");
  channelWrapper.style.display = "flex";
  channelWrapper.style.flexDirection = "column";
  channelWrapper.style.gap = "5px";

  // 创建 iframe 容器
  const iframeWrapper = document.createElement("div");
  iframeWrapper.style.position = "relative";
  iframeWrapper.style.width = "100%";
  iframeWrapper.style.height = 0;
  iframeWrapper.style.overflow = "hidden";
  iframeWrapper.style.borderRadius = "5px";
  iframeWrapper.style.paddingBottom = "56.25%"; // 16:9比例
  
  // 新增：为iframe添加enablejsapi=1，支持YouTube API控制
  iframeWrapper.innerHTML = `<iframe src="https://www.youtube.com/embed/${channel.id}?enablejsapi=1" 
                              style="position:absolute;top:0;left:0;width:100%;height:100%;border:none;"
                              title="${channel.title}" 
                              allowfullscreen
                              id="live-iframe-${channel.id}"></iframe>`;

  // 创建频道信息
  const channelInfo = document.createElement("div");
  channelInfo.style.display = "flex";
  channelInfo.style.flexDirection = "column";
  channelInfo.style.alignItems = "center";
  channelInfo.style.gap = "5px";

  const titleElement = document.createElement("p");
  titleElement.textContent = channel.title;
  titleElement.style.textAlign = "center";
  titleElement.style.margin = "0";
  titleElement.style.fontWeight = "bold";
  titleElement.style.fontSize = "14px";

  channelInfo.appendChild(titleElement);

  // 将生成的 iframe 和频道信息加入页面
  channelWrapper.appendChild(iframeWrapper);
  channelWrapper.appendChild(channelInfo);
  liveChannelFeed.appendChild(channelWrapper);

  // 新增：监听iframe加载，获取播放器实例并加入全局控制
  const iframe = document.getElementById(`live-iframe-${channel.id}`);
  iframe.onload = () => {
    setTimeout(() => {
      const player = new YT.Player(`live-iframe-${channel.id}`, {
        events: {
          'onReady': (event) => {
            // 初始化全局播放器数组（若未存在）
            if (!window.globalYoutubePlayers) window.globalYoutubePlayers = [];
            // 将播放器实例加入全局列表
            if (!window.globalYoutubePlayers.includes(event.target)) {
              window.globalYoutubePlayers.push(event.target);
            }
            // 同步初始状态（静音+音量）
            event.target.mute();
            const globalSlider = document.getElementById('global-volume-slider');
            if (globalSlider) event.target.setVolume(globalSlider.value);
          }
        }
      });
    }, 500);
  };
});
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  // 新增：1. 收集所有画廊图片 & 初始化当前索引
  const galleryImages = Array.from(document.querySelectorAll('.gallery img'));
  let currentImageIndex = 0;

  // 新增：2. 图片切换核心函数（更新放大层图片）
  function updateOverlayImage(index) {
    const overlayImg = document.querySelector('.image-overlay img');
    if (overlayImg && galleryImages[index]) {
      overlayImg.src = galleryImages[index].src;
      overlayImg.alt = galleryImages[index].alt || `图片${index + 1}`;
    }
    currentImageIndex = index; // 更新当前索引
  }

  // 新增：3. 上一张/下一张切换函数（支持循环）
  function showPrevImage() {
    let newIndex = currentImageIndex - 1;
    newIndex = newIndex < 0 ? galleryImages.length - 1 : newIndex; // 循环到最后一张
    updateOverlayImage(newIndex);
  }
  function showNextImage() {
    let newIndex = currentImageIndex + 1;
    newIndex = newIndex >= galleryImages.length ? 0 : newIndex; // 循环到第一张
    updateOverlayImage(newIndex);
  }

  // 原有：全局声音控制初始化（保留）
  window.globalAudioElements = Array.from(document.querySelectorAll('audio'));
  window.isGlobalSoundOn = false;
  const globalSoundBtn = document.getElementById('global-sound-btn');
  const globalVolumeSlider = document.getElementById('global-volume-slider');

  window.globalAudioElements.forEach(audio => {
    audio.muted = !window.isGlobalSoundOn;
    audio.volume = globalVolumeSlider.value / 100;
  });

  // 原有：Gitalk 初始化（保留）
  const gitalk = new Gitalk({
    clientID: 'Ov23lijfU0G3M7jiMFAW',
    clientSecret: '47120dd1810d3a2a9aa0033211f5ee73ef29baa3',
    repo: 'youzai',
    owner: 'fuchenyouzai',
    admin: ['fuchenyouzai'],
    id: location.pathname,
    distractionFreeMode: false,
    language: 'zh-CN'
  });
  gitalk.render('gitalk-container');
  
  // 原有：音量滑块同步逻辑（保留）
  const volumeSlider = document.getElementById('volume-slider');
  volumeSlider.addEventListener('input', (event) => {
    const volume = event.target.value;
    if (window.livePlayer) window.livePlayer.setVolume(volume);
    if (globalVolumeSlider) globalVolumeSlider.value = volume;
    if (window.syncGlobalVolume) window.syncGlobalVolume(volume);
  });

  // 重写：4. 图片点击放大逻辑（替换原逻辑，支持滑动+按钮）
  galleryImages.forEach((img, index) => {
    img.addEventListener('click', () => {
      currentImageIndex = index; // 记录当前点击图片索引

      // 创建放大层容器（带类名方便样式控制）
      const overlay = document.createElement('div');
      overlay.className = 'image-overlay';
      overlay.style.position = 'fixed';
      overlay.style.top = 0;
      overlay.style.left = 0;
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.background = 'rgba(0,0,0,0.9)';
      overlay.style.display = 'flex';
      overlay.style.flexDirection = 'column';
      overlay.style.justifyContent = 'center';
      overlay.style.alignItems = 'center';
      overlay.style.cursor = 'default';
      overlay.style.zIndex = '9999';
      overlay.style.padding = '20px';
      overlay.style.boxSizing = 'border-box';

      // 新增：上一张按钮
      const prevBtn = document.createElement('button');
      prevBtn.textContent = '← 上一张';
      prevBtn.style.position = 'absolute';
      prevBtn.style.left = '20px';
      prevBtn.style.padding = '10px 15px';
      prevBtn.style.backgroundColor = 'rgba(255,255,255,0.2)';
      prevBtn.style.color = 'white';
      prevBtn.style.border = 'none';
      prevBtn.style.borderRadius = '5px';
      prevBtn.style.fontSize = '16px';
      prevBtn.style.cursor = 'pointer';
      prevBtn.style.zIndex = '10';
      prevBtn.style.transition = 'background 0.3s';
      prevBtn.addEventListener('mouseover', () => prevBtn.style.backgroundColor = 'rgba(255,255,255,0.4)');
      prevBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // 阻止关闭放大层
        showPrevImage();
      });

      // 新增：下一张按钮
      const nextBtn = document.createElement('button');
      nextBtn.textContent = '下一张 →';
      nextBtn.style.position = 'absolute';
      nextBtn.style.right = '20px';
      nextBtn.style.padding = '10px 15px';
      nextBtn.style.backgroundColor = 'rgba(255,255,255,0.2)';
      nextBtn.style.color = 'white';
      nextBtn.style.border = 'none';
      nextBtn.style.borderRadius = '5px';
      nextBtn.style.fontSize = '16px';
      nextBtn.style.cursor = 'pointer';
      nextBtn.style.zIndex = '10';
      nextBtn.style.transition = 'background 0.3s';
      nextBtn.addEventListener('mouseover', () => nextBtn.style.backgroundColor = 'rgba(255,255,255,0.4)');
      nextBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // 阻止关闭放大层
        showNextImage();
      });
      // 新增：关闭按钮
      const closeBtn = document.createElement('button');
      closeBtn.textContent = '× 关闭';
      closeBtn.style.position = 'absolute';
      closeBtn.style.top = '20px';
      closeBtn.style.padding = '8px 12px';
      closeBtn.style.backgroundColor = 'rgba(255,0,0,0.6)';
      closeBtn.style.color = 'white';
      closeBtn.style.border = 'none';
      closeBtn.style.borderRadius = '5px';
      closeBtn.style.fontSize = '16px';
      closeBtn.style.cursor = 'pointer';
      closeBtn.style.zIndex = '10';
      closeBtn.style.transition = 'background 0.3s';
      closeBtn.addEventListener('mouseover', () => closeBtn.style.backgroundColor = 'rgba(255,0,0,0.8)');
      closeBtn.addEventListener('click', () => {
        document.body.removeChild(overlay);
        document.removeEventListener('keydown', handleKeyDown); // 移除键盘监听
      });

      // 放大图片元素
      const overlayImg = document.createElement('img');
      overlayImg.src = img.src;
      overlayImg.alt = img.alt || `图片${index + 1}`;
      overlayImg.style.maxWidth = '90%';
      overlayImg.style.maxHeight = '80%';
      overlayImg.style.borderRadius = '5px';
      overlayImg.style.objectFit = 'contain'; // 保证图片不拉伸

      // 组装放大层
      overlay.appendChild(prevBtn);
      overlay.appendChild(nextBtn);
      overlay.appendChild(closeBtn);
      overlay.appendChild(overlayImg);

      // 点击空白处关闭
      overlay.addEventListener('click', () => {
        document.body.removeChild(overlay);
        document.removeEventListener('keydown', handleKeyDown);
      });

      // 新增：移动端触摸滑动支持
      let startX = 0;
      overlay.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX; // 记录触摸起始位置
      });
      overlay.addEventListener('touchend', (e) => {
        if (!e.changedTouches[0]) return;
        const endX = e.changedTouches[0].clientX;
        const diffX = endX - startX; // 计算滑动距离
        if (diffX > 50) showPrevImage(); // 右滑→上一张
        if (diffX < -50) showNextImage(); // 左滑→下一张
      });

      // 新增：PC端键盘方向键控制
      function handleKeyDown(e) {
        if (e.key === 'ArrowLeft') showPrevImage(); // 左箭头→上一张
        if (e.key === 'ArrowRight') showNextImage(); // 右箭头→下一张
        if (e.key === 'Escape') { // ESC键→关闭
          document.body.removeChild(overlay);
          document.removeEventListener('keydown', handleKeyDown);
        }
      }
      document.addEventListener('keydown', handleKeyDown);

      // 加入页面
      document.body.appendChild(overlay);
    });
  });

  // 原有：YouTube视频墙逻辑（保留，无修改）
  const videos = [
    {id: "ZB9QSD_SWmM", type: "shorts", title: "最新 Shorts 视频"},
    {id: "ZB9QSD_SWmM", type: "shorts", title: "示例视频 1"},
    {id: "ZB9QSD_SWmM", type: "shorts", title: "示例视频 2"},
    {id: "ZB9QSD_SWmM", type: "video", title: "示例视频 2"},
    {id: "ZB9QSD_SWmM", type: "video", title: "示例视频 2"},
    {id: "ZB9QSD_SWmM", type: "video", title: "示例视频 2"}
  ];
  const feedContainer = document.getElementById("youtube-feed");
  if (feedContainer) {
    videos.forEach((v, index) => {
      const wrapper = document.createElement("div");
      wrapper.style.display = "flex";
      wrapper.style.flexDirection = "column";
      wrapper.style.gap = "5px";

      const iframeWrapper = document.createElement("div");
      iframeWrapper.style.position = "relative";
      iframeWrapper.style.width = "100%";
      iframeWrapper.style.height = 0;
      iframeWrapper.style.overflow = "hidden";
      iframeWrapper.style.borderRadius = "5px";
      iframeWrapper.style.paddingBottom = v.type === "shorts" ? "177.78%" : "56.25%";
      const iframeId = `video-iframe-${index}`;
      iframeWrapper.innerHTML = `<iframe src="https://www.youtube.com/embed/${v.id}?enablejsapi=1" 
              style="position:absolute;top:0;left:0;width:100%;height:100%;border:none;"
              title="${v.title}" 
              allowfullscreen
              id="${iframeId}"></iframe>`;

      const infoDiv = document.createElement("div");
      infoDiv.style.display = "flex";
      infoDiv.style.flexDirection = "column";
      infoDiv.style.alignItems = "center";
      infoDiv.style.gap = "5px";

      const titleEl = document.createElement("p");
      titleEl.textContent = v.title;
      titleEl.style.textAlign = "center";
      titleEl.style.margin = "0";
      titleEl.style.fontWeight = "bold";
      titleEl.style.fontSize = "14px";

      const btn = document.createElement("a");
      btn.href = `https://www.youtube.com/watch?v=${v.id}`;
      btn.target = "_blank";
      btn.textContent = "在 YouTube 上观看";
      btn.style.display = "inline-block";
      btn.style.padding = "5px 10px";
      btn.style.backgroundColor = "#ff0000";
      btn.style.color = "#fff";
      btn.style.borderRadius = "4px";
      btn.style.fontSize = "12px";
      btn.style.textDecoration = "none";

      infoDiv.appendChild(titleEl);
      infoDiv.appendChild(btn);
      wrapper.appendChild(iframeWrapper);
      wrapper.appendChild(infoDiv);
      feedContainer.appendChild(wrapper);

      const videoIframe = document.getElementById(iframeId);
      videoIframe.onload = () => {
        setTimeout(() => {
          const player = new YT.Player(iframeId, {
            events: {
              'onReady': (event) => {
                if (!window.globalYoutubePlayers) window.globalYoutubePlayers = [];
                if (!window.globalYoutubePlayers.includes(event.target)) {
                  window.globalYoutubePlayers.push(event.target);
                }
                event.target.mute();
                if (globalVolumeSlider) event.target.setVolume(globalVolumeSlider.value);
              }
            }
          });
        }, 500);
      };
    });
  }
  // 原有：PWA Service Worker 注册（保留）
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js')
      .then(registration => console.log('Service Worker 注册成功:', registration.scope))
      .catch(err => console.log('Service Worker 注册失败:', err));
  }

  // 原有：全局音量同步函数（保留）
  window.syncGlobalVolume = function(volume) {
    if (window.globalAudioElements) {
      window.globalAudioElements.forEach(audio => {
        if (audio) audio.volume = volume / 100;
      });
    }
    if (window.globalYoutubePlayers) {
      window.globalYoutubePlayers.forEach(player => {
        if (player && typeof player.setVolume === 'function') {
          player.setVolume(volume);
        }
      });
    }
    if (window.livePlayer) {
      window.livePlayer.setVolume(volume);
    }
  };

  // 原有：全局声音开关函数（保留）
  window.toggleGlobalSound = function() {
    window.isGlobalSoundOn = !window.isGlobalSoundOn;
    if (globalSoundBtn) {
      globalSoundBtn.textContent = window.isGlobalSoundOn ? '🔇 全局静音' : '🔊 全局有声';
    }
    if (window.globalAudioElements) {
      window.globalAudioElements.forEach(audio => {
        if (audio) audio.muted = !window.isGlobalSoundOn;
      });
    }
    if (window.globalYoutubePlayers) {
      window.globalYoutubePlayers.forEach(player => {
        if (player && typeof player.mute === 'function' && typeof player.unMute === 'function') {
          window.isGlobalSoundOn ? player.unMute() : player.mute();
        }
      });
    }
    if (window.livePlayer) {
      window.isGlobalSoundOn ? window.livePlayer.unMute() : window.livePlayer.mute();
    }
    const originalSoundBtn = document.getElementById('sound-toggle-btn');
    if (originalSoundBtn) {
      const originalIsOn = originalSoundBtn.textContent.includes('关闭');
      if (originalIsOn !== window.isGlobalSoundOn) {
        originalSoundBtn.click();
      }
    }
  };

  // 原有：PWA安装按钮逻辑（保留）
  const installBtn = document.getElementById('install-btn');
  let deferredPrompt;
  const isEdge = /Edg/i.test(navigator.userAgent);
  const isChrome = /Chrome/i.test(navigator.userAgent) && !isEdge;

  if (isChrome) {
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
    });
  }

  installBtn.addEventListener('click', async () => {
    if (isChrome) {
      if (!deferredPrompt) { alert("PWA 安装条件未满足，或已安装"); return; }
      deferredPrompt.prompt();
      await deferredPrompt.userChoice;
      deferredPrompt = null;
    } else if (isEdge) {
      alert("请通过浏览器菜单选择“点添加到手机或点安装或点创建快捷方式”来安装到手机或电脑或平板中使用。");
    } else {
      alert("当前浏览器不支持自动安装，请使用 Chrome 或 Edge 浏览器。");
    }
  });

  // 原有：绑定全局控制按钮事件（保留）
  if (globalSoundBtn) {
    globalSoundBtn.addEventListener('click', window.toggleGlobalSound);
  }
  if (globalVolumeSlider) {
    globalVolumeSlider.addEventListener('input', (e) => {
      const volume = e.target.value;
      window.syncGlobalVolume(volume);
    });
  }

}); // DOMContentLoaded 结束
</script>
<script>
// 原有：YouTube Player API 初始化相关变量（新增全局挂载）
window.livePlayer;
window.soundOn = false;

// 原有：onYouTubeIframeAPIReady函数（新增主播放器加入全局控制）
function onYouTubeIframeAPIReady() {
  const latestLiveID = 'fN9uYWCjQaw';
  window.livePlayer = new YT.Player('live-player', {
    videoId: latestLiveID,
    playerVars: { autoplay: 1, mute: 1, controls: 1, modestbranding: 1 },
    events: { 
      'onReady': (event) => { 
        event.target.mute(); 
        // 新增：将主直播播放器加入全局列表
        if (!window.globalYoutubePlayers) window.globalYoutubePlayers = [];
        if (!window.globalYoutubePlayers.includes(event.target)) {
          window.globalYoutubePlayers.push(event.target);
        }
        // 同步全局音量
        const globalSlider = document.getElementById('global-volume-slider');
        if (globalSlider) event.target.setVolume(globalSlider.value);
      } 
    }
  });
}

// 原有：右下角声音开关按钮（保留原逻辑，与全局控制联动）
const soundBtn = document.getElementById('sound-toggle-btn');
soundBtn.addEventListener('click', () => {
  if (!window.livePlayer) return;
  window.soundOn = !window.soundOn;
  // 更新原有按钮文字
  soundBtn.textContent = window.soundOn ? '🔇 关闭声音' : '🔊 打开声音';
  // 同步主直播播放器
  window.soundOn ? window.livePlayer.unMute() : window.livePlayer.mute();
  // 同步全局状态与其他音频/视频
  if (window.isGlobalSoundOn !== window.soundOn) {
    window.isGlobalSoundOn = window.soundOn;
    const globalSoundBtn = document.getElementById('global-sound-btn');
    if (globalSoundBtn) {
      globalSoundBtn.textContent = window.soundOn ? '🔇 全局静音' : '🔊 全局有声';
    }
    // 同步原生音频与其他YouTube播放器
    if (window.globalAudioElements) {
      window.globalAudioElements.forEach(audio => {
        if (audio) audio.muted = !window.soundOn;
      });
    }
    if (window.globalYoutubePlayers) {
      window.globalYoutubePlayers.forEach(player => {
        if (player !== window.livePlayer && player && typeof player.mute === 'function' && typeof player.unMute === 'function') {
          window.soundOn ? player.unMute() : player.mute();
        }
      });
    }
  }
});

// 原有：白天/夜晚模式切换按钮（保留原逻辑，无修改）
const modeBtn = document.getElementById('mode-toggle-btn');
const currentMode = localStorage.getItem('theme') || 'light'; // 默认使用 'light' 模式
if (currentMode === 'dark') {
  document.body.classList.add('dark-mode');
  modeBtn.textContent = "☀️ 白天模式";
} else {
  document.body.classList.remove('dark-mode');
  modeBtn.textContent = "🌙 夜晚模式";
}

modeBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  if (document.body.classList.contains('dark-mode')) {
    modeBtn.textContent = "☀️ 白天模式";
    localStorage.setItem('theme', 'dark'); // 保存夜间模式
  } else {
    modeBtn.textContent = "🌙 夜晚模式";
    localStorage.setItem('theme', 'light'); // 保存白天模式
  }
});
</script>
</body>
</html>
